// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

// TODO: Generated by Claude Sonnet

// import { Test } from "forge-std/Test.sol";
// import { ERC20TokenFactoryV2 } from "../src/contract-factory/erc20-token-factory-v2.sol";
// import { BaseERC20Token } from "../src/contract-factory/base-erc-20-token.sol";
// contract ERC20TokenFactoryV2Test is Test {
//   ERC20TokenFactoryV2 public factory;
//   BaseERC20Token public baseToken;

//   function setUp() public {
//     baseToken = new BaseERC20Token();
//     factory = new ERC20TokenFactoryV2(address(baseToken));
//   }

//   function testDeployInscription(string memory symbol, uint256 maxSupply, uint256 perMint, uint256 price) public {
//     vm.assume(perMint <= maxSupply);
//     address tokenAddr = factory.deployInscription(symbol, maxSupply, perMint, price);
//     BaseERC20Token token = BaseERC20Token(tokenAddr);
//     assertEq(token.symbol(), symbol);
//     assertEq(token.owner(), address(factory));
//   }

//   function testRevertDeployInscriptionInvalidArgs(string memory symbol, uint256 maxSupply, uint256 perMint, uint256 price) public {
//     vm.assume(perMint > maxSupply);
//     vm.expectRevert(abi.encodeWithSelector(BaseERC20Token.InvalidArgs.selector, maxSupply, perMint));
//     factory.deployInscription(symbol, maxSupply, perMint, price);
//   }

//   function testMintInscription(string memory symbol, uint256 maxSupply, uint256 perMint, uint256 price) public {
//     vm.assume(perMint <= maxSupply);
//     address tokenAddr = factory.deployInscription(symbol, maxSupply, perMint, price);
//     address deployer = makeAddr("deployer");
//     vm.deal(deployer, price);
//     vm.startPrank(deployer);
//     vm.expectEmit(true, true, true, true);
//     emit BaseERC20Token.Minted(deployer, perMint);
//     factory.mintInscription{value: price}(tokenAddr);
//     vm.stopPrank();
//     BaseERC20Token token = BaseERC20Token(tokenAddr);
//     assertEq(token.balanceOf(deployer), perMint);
//   }

//   function testRevertMintInscriptionExceedsMaxSupply(string memory symbol, uint256 maxSupply, uint256 price) public {
//     vm.assume(maxSupply > 0 && maxSupply < type(uint256).max / 2);
//     uint256 perMint = maxSupply;
//     address tokenAddr = factory.deployInscription(symbol, maxSupply, perMint, price);
//     address deployer = makeAddr("deployer");
//     vm.deal(deployer, price * 2);
//     vm.startPrank(deployer);
//     factory.mintInscription{value: price}(tokenAddr);
//     vm.expectRevert(abi.encodeWithSelector(BaseERC20Token.ExceedsMaxSupply.selector));
//     factory.mintInscription{value: price}(tokenAddr);
//     vm.stopPrank();
//   }

//   function testRevertMintInscriptionNotReachedTokenPrice(string memory symbol, uint256 maxSupply, uint256 perMint, uint256 price) public {
//     vm.assume(perMint <= maxSupply);
//     vm.assume(price > 0);
//     address tokenAddr = factory.deployInscription(symbol, maxSupply, perMint, price);
//     address deployer = makeAddr("deployer");
//     vm.deal(deployer, price - 1);
//     vm.startPrank(deployer);
//     vm.expectRevert(abi.encodeWithSelector(ERC20TokenFactoryV2.NotReachedTokenPrice.selector, price, price - 1));
//     factory.mintInscription{value: price - 1}(tokenAddr);
//     vm.stopPrank();
//   }
// }
